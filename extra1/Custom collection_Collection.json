{"content": "\nThe Java JDK collection implementations are quite powerful and good, so it is unlikely that you will need to write your own. The usage of the different collections are the same but the implementations are different. If the existing collection implementations do not meet your needs, you can write your version of the implementation. Your version of the implementation just needs to implement the same java.util.Collection interface, then you can switch to using your implementation and the code that is using the collection does not need to be changed.\n\nUse the Collection interface if you need to keep related (usually the same type of) objects together in a collection where you can:\n\nSearch for a particular element\nList the elements\nMaintain and/or change the order of the elements by using the collection basic operations (Add, Remove, Update,..)\nAccess the elements by an index number\nThe advantages of using the Collection interface are:\n\nGives a generic usage, as we talked about above, it is easy to switch implementation\nIt makes it easy to convert one type of collection to another.\nThe Collection interface defines the following basic operations:\n\n\n\nboolean add(E o);\n\nUsing Element type E\n\n\nboolean addAll(Collection c);\n\n\n\n\nboolean remove(Object o);\n\n\n\n\nboolean removeAll(Collection c);\n\n\n\n\nboolean retainAll(Collection c);\n\nReturn true if the collection has changed due to the operation.\n\nNote that in addAll() we can add any type of collection.  This is the beauty of using the Collection interface. You can have a LinkedList and just call the addAll(list) method, passing in a list.  You can pass in a Vector, an ArrayList, a HashSet, a TreeSet, a YourImpOfCollection, ...\nAll those different types of collection will be magically converted to a LinkedList.\n\nLet's have a closer look at this magic.  The conversion is easy because the Collection interface defines  a standard way of looping through the elements.  The following code is a possible implementation of addAll() method of the LinkedList.\n\n\n\n\n\nCode section 5.6: Collection transfer.\n 1 import java.util.Collection\n 2 import java.util.Iterator\n 3 ...\n 4 public boolean addAll(Collection coll) {\n 5    int sizeBefore = this.size();\n 6    Iterator iter = coll.iterator();\n 7    while(iter.hasNext()) {\n 8       this.add(iter.next());\n 9    }\n10    if (sizeBefore > this.size()) {\n11       return true;\n12    } else {\n13       return false;\n14    }\n15 }\n\n\nThe above code just iterates through the passed in collection and adds the elements to the linked list. You do not have to do that, since that is already defined. What you might need to code for is to loop through a Customer collection:\n\n\n\n\n\nCode section 5.7: Iteration on a collection.\n 1 import java.util.Collection\n 2 import java.util.Iterator\n 3 import java.yourcompany.Customer\n 4 ...\n 5 public String printCustomerNames(Collection customerColl) {\n 6    StringBuffer buf = new StringBuffer();\n 7 \n 8    Iterator iter = customerColl.iterator();\n 9    while(iter.hasNext()) {\n10       Customer cust = (Customer) iter.next();\n11       buf.append(cust.getName());\n12       buf.append( \"\\n\" );\n13    }\n14   return buf.toString();\n15 }\n\n\nThe above code will work for all type of collections.\nWe have to know the type of objects inside the collection, because we call a method on it.\n\n\n\n\n\nTo do:Add some exercises like the ones in Variables\n\n\n\n\n Aggregate\n\nJava ProgrammingCollection\n\nArrayList \n", "heading": "Custom collection"}