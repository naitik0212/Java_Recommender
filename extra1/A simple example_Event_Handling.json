{"content": "\nIn the previous section we've explored the depths (such as there are) of the Java platform Event Model framework. If you're like most people, you've found the theoretical text more confusing than the actual use of the model. Certainly more confusing than should be necessary to explain what is, really, quite a simple framework.\n\nIn order to clear everything up a bit, let's examine a simple example based on the Event Model framework. Let's assume that we want to write a program that reads a stream of numbers input by the user at the command line and processes this stream somehow. Say, by keeping track of the running sum of numbers and producing that sum once the stream has been completely read.\n\nOf course we could implement this program quite simply with a loop in a main() method. But instead let's be a little more creative. Let's say that we want to divide our program neatly into classes, each with a responsibility of its own (like we should in a proper, object-oriented design). And let's imagine that we want it to be possible not only to calculate the sum of all the numbers read, but to perform any number of calculations on the same number stream. In fact, it should be possible to add new calculations with relative ease and without having to affect any previously existing code.\n\nIf we analyze these requirements, we come to the conclusion that we have a number of different responsibilities in the program:\n\n\n\n\nReading the number stream from the command line\nProcessing the number stream (possibly multiple of these)\nStarting the entire program\n\nUsing the Event Model framework allows us to separate the two main responsibilities cleanly and affords us the flexibility we are looking for. If we implement the logic for reading the number stream in a single class and treat the reading of a single number as an event, the Event Model allows us to broadcast that event (and the number) to as many stream processors as we like. The class for reading the number stream will act as the event source of the program and each stream processor will be a listener. Since each listener is a class of its own and can be registered with the stream reader (or not) this means our model allows us to have multiple, independent stream processing that we can add on to without affecting the code to read the stream or any pre-existing stream processor.\n\nThe Event Model says that any state associated with an event should be included in a class that represents the event. That's perfect for us; we can implement a simple event class that will record the number read from the command line. Each listener can then process this number as it sees fit.\n\nFor our interesting event set let's keep things simple: let's limit ourselves to having read a new number and having reached the end of the stream. With this choice we come to the following design for our example application:\n\nIn the following sections we look at the implementation of this example.\n\nLet's start with the basics. According to the Event Model rules, we must define an event class to encapsulate our interesting event. We should call this class something-somethingEvent. Let's go for NumberReadEvent, since that's what will interest us. According to the Model rules, this class should encapsulate any state that belongs with an event occurrence. In our case, that's the number read from the stream. And our event class must inherit from java.util.EventObject. So all in all, the following class is all we need:\n\n\n\n\n\nCode listing 1.1: NumberReadEvent.\npackage org.wikibooks.en.javaprogramming.example;\n\nimport java.util.EventObject;\n\npublic class NumberReadEvent extends EventObject {\n\n    private double number;\n   \n    public NumberReadEvent(Object source, Double number) {\n        super(source);\n        this.number = number;\n    }\n\n    public double getNumber() {\n        return number;\n    }\n}\n\n\nNext, we must define a listener interface. This interface must define methods for interesting events and must extend java.util.EventListener. We said earlier our interesting events were \"number read\" and \"end of stream reached\", so here we go:\n\n\n\n\n\nCode listing 1.2: NumberReadListener.\npackage org.wikibooks.en.javaprogramming.example;\n\nimport java.util.EventListener;\n\npublic interface NumberReadListener extends EventListener {\n    public void numberRead(NumberReadEvent numberReadEvent);\n   \n    public void numberStreamTerminated(NumberReadEvent numberReadEvent);\n}\n\n\nActually the numberStreamTerminated method is a little weird, since it isn't actually a \"number read\" event. In a real program you'd probably want to do this differently. But let's keep things simple in this example.\n\nThe event listener implementation[edit]\nSo, with our listener interface defined, we need one or more implementations (actual listener classes). At the very least we need one that will keep a running sum of the numbers read. We can add as many as we like, of course. But let's stick with just one for now. Obviously, this class must implement our NumberReadListener interface. Keeping a running summation is a matter of adding numbers to a field as the events arrive. And we wanted to report on the sum when the end of the stream is reached; since we know when that happens (i.e. the numberStreamTerminated method is called), a simple println statement will do:\n\n\n\n\n\nCode listing 1.3: NumberReadListenerImpl.\npackage org.wikibooks.en.javaprogramming.example;\n\npublic class NumberReadListenerImpl implements NumberReadListener {\n   \n    double totalSoFar = 0D;\n\n    @Override\n    public void numberRead(NumberReadEvent numberReadEvent) {\n        totalSoFar += numberReadEvent.getNumber();\n    }\n\n    @Override\n    public void numberStreamTerminated(NumberReadEvent numberReadEvent) {\n        System.out.println(\"Sum of the number stream: \" + totalSoFar);\n    }\n}\n\n\nSo, is this code any good? No. It's yucky and terrible and most of all not thread safe. But it will do for our example.\n\nThe event source[edit]\nThis is where things get interesting: the event source class. This is the interesting place because this is where we must put code to read the number stream, code to send events to all the listeners and code to manage listeners (add and remove them and keep track of them).\n\nLet's start by thinking about keeping track of listeners. Normally this is a tricky business, since you have to take all sorts of multithreading concerns into account. But we're being simple in this example, so let's just stick with a simple java.util.Set of listeners. Which we can initialize in the constructor:\n\n\n\n\n\nCode section 1.1: The constructor\nprivate Set<NumberReadListener> listeners;\n   \npublic NumberReader() {\n    listeners = new HashSet<NumberReadListener>();\n}\n\n\nThat choice makes it really easy to implement adding and removing of listeners:\n\n\n\n\n\nCode section 1.2: The register/deregister\npublic void addNumberReadListener(NumberReadListener listener) {\n    this.listeners.add(listener);\n}\n\npublic void removeNumberReadListener(NumberReadListener listener) {\n    this.listeners.remove(listener);\n}\n\n\nWe won't actually use the remove method in this example \u2014 but recall that the Model says it must be present.\n\nAnother advantage of this simple choice is that notification of all the listeners is easy as well. We can just assume any listeners will be in the set and iterate over them. And since the notification methods are synchronous (rule of the model) we can just call them directly:\n\n\n\n\n\nCode section 1.3: The notifiers\nprivate void notifyListenersOfEndOfStream() {\n    for (NumberReadListener numberReadListener : listeners) {\n        numberReadListener.numberStreamTerminated(new NumberReadEvent(this, 0D));\n    }\n}\n\nprivate void notifyListeners(Double d) {\n    for (NumberReadListener numberReadListener: listeners) {\n        numberReadListener.numberRead(new NumberReadEvent(this, d));\n    }\n}\n\n\nNote that we've made some assumptions here. For starters, we've assumed that we'll get the Double value d from somewhere. Also, we've assumed that no listener will ever care about the number value in the end-of-stream notification and have passed in the fixed value 0 for that event.\n\nFinally we must deal with reading the number stream. We'll use the Console class for that and just keep on reading numbers until there are no more:\n\n\n\n\n\nCode section 1.4: The main method\npublic void start() {\n    Console console = System.console();\n    if (console != null) {\n        Double d = null;\n        do {\n            String readLine = console.readLine(\"Enter a number: \", (Object[])null);\n            d = getDoubleValue(readLine);\n            if (d != null) {\n                notifyListeners(d);\n            }\n        } while (d != null);\n        notifyListenersOfEndOfStream();\n    }\n}\n\n\nNote how we've hooked the number-reading loop into the event handling mechanism by calling the notify methods? The entire class looks like this:\n\n\n\n\n\nCode listing 1.4: NumberReader.\npackage org.wikibooks.en.javaprogramming.example;\n\nimport java.io.Console;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class NumberReader {\n    private Set<NumberReadListener> listeners;\n   \n    public NumberReader() {\n        listeners = new HashSet<NumberReadListener>();\n    }\n   \n    public void addNumberReadListener(NumberReadListener listener) {\n        this.listeners.add(listener);\n    }\n   \n    public void removeNumberReadListener(NumberReadListener listener) {\n        this.listeners.remove(listener);\n    }\n   \n    public void start() {\n        Console console = System.console();\n        if (console != null) {\n            Double d = null;\n            do {\n                String readLine = console.readLine(\"Enter a number: \", (Object[])null);\n                d = getDoubleValue(readLine);\n                if (d != null) {\n                    notifyListeners(d);\n                }\n            } while (d != null);\n            notifyListenersOfEndOfStream();\n        }\n    }\n\n    private void notifyListenersOfEndOfStream() {\n        for (NumberReadListener numberReadListener: listeners) {\n            numberReadListener.numberStreamTerminated(new NumberReadEvent(this, 0D));\n        }\n    }\n\n    private void notifyListeners(Double d) {\n        for (NumberReadListener numberReadListener: listeners) {\n            numberReadListener.numberRead(new NumberReadEvent(this, d));\n        }\n    }\n\n    private Double getDoubleValue(String readLine) {\n        Double result;\n        try {\n            result = Double.valueOf(readLine);\n        } catch (Exception e) {\n            result = null;\n        }\n        return result;\n    }\n}\n\n\nRunning the example[edit]\nFinally, we need one more class: the kickoff point for the application. This class will contain a main() method, plus code to create a NumberReader, a listener and to combine the two:\n\n\n\n\n\nCode listing 1.5: Main.\npackage org.wikibooks.en.javaprogramming.example;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        NumberReader reader = new NumberReader();\n        NumberReadListener listener = new NumberReadListenerImpl();\n        reader.addNumberReadListener(listener);\n        reader.start();\n    }\n}\n\n\nIf you compile and run the program, the result looks somewhat like this:\n\n\n\n\n\nAn example run\n>java org.wikibooks.en.javaprogramming.example.Main\nEnter a number: 0.1\nEnter a number: 0.2\nEnter a number: 0.3\nEnter a number: 0.4\nEnter a number:\n\n\n\n\n\n\nOutput\nSum of the number stream: 1.0\n\n\nExtending the example with an adaptor[edit]\nNext, let's take a look at applying an adaptor to our design. Adaptors are used to add functionality to the event handling process that:\n\nis general to the process and not specific to any one listener; or\nis not supposed to affect the implementation of specific listeners.\nAccording to the Event Model specification a typical use case for an adaptor is to add routing logic for events. But you can also add filtering or logging. In our case, let's do that: add logging of the numbers as \"proof\" for the calculations done in the listeners.\n\nAn adaptor, as explained earlier, is a class that sits between the event source and the listeners. From the point of view of the event source, it masquerades as a listener (so it must implement the listener interface). From the point of view of the listeners it pretends to be the event source (so it should have add and remove methods). In other words, to write an adaptor you have to repeat some code from the event source (to manage listeners) and you have to re-implement the event notification methods to do some extra stuff and then pass the event on to the actual listeners.\n\nIn our case we need an adaptor that writes the numbers to a log file. Keeping it simple once again, let's settle for an adaptor that:\n\nUses a fixed log file name and overwrites that log file with every program run.\nOpens a FileWriter in the constructor and just keeps it open.\nImplements the numberRead method by writing the number to the FileWriter.\nImplements the numberStreamTerminated method by closing the FileWriter.\nAlso, we can make life easy on ourselves by just copying all the code we need to manage listeners over from the NumberReader class. Again, in a real program you'd want to do this differently. Note that each notification method implementation also passes the event on to all the real listeners:\n\n\n\n\n\nCode listing 1.6: NumberReaderLoggingAdaptor.\npackage org.wikibooks.en.javaprogramming.example;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class NumberReaderLoggingAdaptor implements NumberReadListener {\n    private Set<NumberReadListener> listeners;\n    private BufferedWriter output;\n   \n    public NumberReaderLoggingAdaptor() {\n        listeners = new HashSet<NumberReadListener>();\n        try {\n            output = new BufferedWriter(new FileWriter(\"numberLog.log\"));\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n   \n    public void addNumberReadListener(NumberReadListener listener) {\n        this.listeners.add(listener);\n    }\n   \n    public void removeNumberReadListener(NumberReadListener listener) {\n        this.listeners.remove(listener);\n    }\n   \n   \n    @Override\n    public void numberRead(NumberReadEvent numberReadEvent) {\n        try {\n            output.write(numberReadEvent.getNumber() + \"\\n\");\n        } catch (Exception e) {\n           \n        }\n        for (NumberReadListener numberReadListener: listeners) {\n            numberReadListener.numberRead(numberReadEvent);\n        }\n    }\n\n    @Override\n    public void numberStreamTerminated(NumberReadEvent numberReadEvent) {\n        try {\n            output.flush();\n            output.close();\n        } catch (Exception e) {\n           \n        }\n        for (NumberReadListener numberReadListener: listeners) {\n            numberReadListener.numberStreamTerminated(numberReadEvent);\n        }\n    }\n\n}\n\n\nOf course, to make the adaptor work we have to make some changes to the bootstrap code:\n\n\n\n\n\nCode listing 1.7: Main.\npackage org.wikibooks.en.javaprogramming.example;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        NumberReader reader = new NumberReader();\n        NumberReadListener listener = new NumberReadListenerImpl();\n        NumberReaderLoggingAdaptor adaptor = new NumberReaderLoggingAdaptor();\n        adaptor.addNumberReadListener(listener);\n        reader.addNumberReadListener(adaptor);\n        reader.start();\n    }\n}\n\n\nBut note how nicely and easily we can re-link the objects in our system. The fact that adaptors and listeners both implement the listener interface and the adaptor and event source both look like event sources means that we can hook the adaptor into the system without having to change a single statement in the classes that we developed earlier.\n\nAnd of course, if we run the same example as given above, the numbers are now recorded in a log file.\n", "heading": "A simple example"}