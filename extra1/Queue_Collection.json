{"content": "\nThe Queue interface provides additional insertion, extraction, and inspection operations. There are FIFO (first in, first out) and LIFO (last in, first out) queues. This interface adds the following operations to the Collection interface:\n\n\n\nE element()\n\nRetrieves, but does not remove, the head of this queue. This method differs from the peek method only in that it throws an exception if this queue is empty\n\n\nboolean offer(E o)\n\nInserts the specified element into this queue, if possible.\n\n\nE peek()\n\nRetrieves, but does not remove, the head of this queue, returning null if this queue is empty\n\n\nE poll()\n\nRetrieves and removes the head of this queue, or null if this queue is empty\n\n\nE remove()\n\nRetrieves and removes the head of this queue. This method differs from the poll method in that it throws an exception if this queue is empty.\n\n\n\nFigure 4: Queue class diagram.\n\n\n\n\njava.util.BlockingQueue<E>\u00a0\nwaits for the queue to become non-empty when retrieving an element, and waits for space to become available in the queue when storing an element. Best used for producer-consumer queues.\njava.util.PriorityQueue<E>\u00a0\norders elements according to an order/priority  specified at construction time, null element is not allowed.\njava.util.concurrent.ArrayBlockingQueue<E>\u00a0\norders elements FIFO; synchronized, thread safe.\njava.util.concurrent.SynchronousQueue<E>\u00a0\neach put must wait for a take, and vice versa, does not have any internal capacity, not even a capacity of one, an element is only present when you try to take it; you cannot add an element (using any method) unless another thread is trying to remove it.", "heading": "Queue"}