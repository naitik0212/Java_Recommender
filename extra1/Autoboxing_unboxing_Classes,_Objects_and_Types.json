{"content": "\nAutoboxing and unboxing, language features since Java 1.5, make the programmer's life much easier when it comes to working with the primitive wrapper types. Consider this code fragment:\n\n\n\n\n\nCode section 3.85: Traditional object creation.\n1 int age = 23;\n2 Integer ageObject = new Integer(age);\n\n\nPrimitive wrapper objects were Java's way of allowing one to treat primitive data types as though they were objects. Consequently, one was expected to wrap one's primitive data type with the corresponding primitive wrapper object, as shown above.\n\nSince Java 1.5, one may write as below and the compiler will automatically create the wrap object. The extra step of wrapping the primitive is no longer required. It has been automatically boxed up on your behalf:\n\n\n\n\n\nCode section 3.86: Autoboxing.\n1 int age = 23;\n2 Integer ageObject = age;\n\n\n\n\n\n\nKeep in mind that the compiler still creates the missing wrapper code, so one doesn't really gain anything performance-wise. Consider this feature a programmer convenience, not a performance booster.\n\nEach primitive type has a class wrapper:\n\n\n\nPrimitive type\n\nClass wrapper\n\n\nbyte\njava.lang.Byte\n\n\nchar \njava.lang.Character\n\n\nshort \njava.lang.Short\n\n\nint\njava.lang.Integer\n\n\nlong\njava.lang.Long\n\n\nfloat\njava.lang.Float\n\n\ndouble\njava.lang.Double\n\n\nboolean\njava.lang.Boolean\n\n\nvoid\njava.lang.Void\n\nUnboxing uses the same process in reverse. Study the following code for a moment. The if statement requires a boolean primitive value, yet it was given a Boolean wrapper object. No problem! Java 1.5 will automatically unbox this.\n\n\n\n\n\nCode section 3.87: Unboxing.\n1 Boolean canMove = new Boolean(true);\n2  \n3 if (canMove) {\n4   System.out.println(\"This code is legal in Java 1.5\");\n5 }\n\n", "heading": "Autoboxing/unboxing"}