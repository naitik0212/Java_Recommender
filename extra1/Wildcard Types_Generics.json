{"content": "\nAs we have seen above, generics give the impression that a new container type is created with each different type parameter. We have also seen that in addition to the normal type checking, the type parameter has to match as well when we assign generics variables.\nIn some cases this is too restrictive.  What if we would like to relax this additional checking? What if we would like to define a collection variable that can hold any generic collection, regardless of the parameter type it holds?\nThe wildcard type is represented by the character <?>, and pronounced Unknown, or Any-Type. Any-Type can be expressed also by <? extends Object>. Any-Type includes Interfaces, not only Classes.\nSo now we can define a collection whose element type matches anything. See below:\n\n\n\n\n\nCode section 4.39: Wildcard type.\n1 Collection<?> collUnknown;\n\n\nUpper bounded wildcards[edit]\nYou can specify a restriction on the types of classes that may be used. For example, <? extends ClassName> only allows objects of class ClassName or a subclass.\nFor example, to create a collection that may only contain \"Serializable\" objects, specify:\n\n\n\n\n\nCode section 4.40: Collection of serializable subobjects.\n1 Collection<String> textColl = new ArrayList<String>();\n2 \n3 Collection<? extends Serializable> serColl = textColl;\n\n\nThe above code is valid because the String class is serializable. Use of a class that is not serializable would cause a compilation error. The added items can be retrieved as Serializable object. You can call methods of the Serializable interface or cast it to String. The following collection can only contain objects that extend the class Animal.\n\n\n\n\n\nCode listing 4.38: Dog.java\n1 class Dog extends Animal {\n2 }\n\n\n\n\n\n\nCode section 4.41: Example of subclass.\n1 // Create \"Animal Collection\" variable\n2 Collection<? extends Animal> animalColl = new ArrayList<Dog>();\n\n\nLower bounded wildcards[edit]\n<? super ClassName> specifies a restriction on the types of classes that may be used.\nFor example, to declare a Comparator that can compare Dogs, you use:\n\n\n\n\n\nCode section 4.42: Superclass.\n1 Comparator<? super Dog> myComparator;\n\n\nNow suppose you define a comparator that can compare Animals:\n\n\n\n\n\nCode section 4.43: Comparator.\n1 class AnimalComparator implements Comparator<Animal> {\n2   int compare(Animal a, Animal b) {\n3    //...\n4   }\n5 }\n\n\nSince Dogs are Animals, you can use this comparator to compare Dogs also. Comparators for any superclass of Dog can also compare Dog; but comparators for any strict subclass cannot.\n\n\n\n\n\nCode section 4.44: Generic comparator.\n1 Comparator<Animal> myAnimalComparator = new AnimalComparator();\n2 \n3 static int compareTwoDogs(Comparator<? super Dog> comp, Dog dog1, Dog dog2) {\n4   return comp.compare(dog1, dog2);\n5 }\n\n\nThe above code is valid because the Animal class is a supertype of the Dog class. Use of a class that is not a supertype would cause a compilation error.\n\nUnbounded wildcard[edit]\nThe advantage of the unbounded wildcard (i.e. <?>) compared to a raw type (i.e. without generic) is to explicitly say that the parameterized type is unknown, not any type. That way, all the operations that implies to know the type are forbidden to avoid unsafe operation. Consider the following code:\n\n\n\n\n\nCode section 4.45: Unsafe operation.\n1 public void addAtBottom(Collection anyCollection) {\n2   anyCollection.add(new Integer(1));\n3 }\n\n\nThis code will compile but this code may corrupt the collection if the collection only contains strings:\n\n\n\n\n\n\n\n\nCode section 4.46: Corruption of list.\n1 List<String> col = new ArrayList<String>();\n2 addAtBottom(col);\n3 col.get(0).endsWith(\".\");\n\n\n\n\n\n\n\n\nConsole for Code section 4.46\nException in thread \"main\" java.lang.ClassCastException: java.lang.Integer incompatible with java.lang.String\nat Example.main(Example.java:17)\n\n\n\nThis situation could have been avoided if the addAtBottom(Collection) method was defined with an unbounded wildcard: addAtBottom(Collection<?>). With this signature, it is impossible to compile a code that is dependent of the parameterized type. Only independent methods of a collection (clear(), isEmpty(), iterator(), remove(Object o), size(), ...) can be called. For instance, addAtBottom(Collection<?>) could contain the following code:\n\n\n\n\n\nCode section 4.47: Safe operation.\n1 public void addAtBottom(Collection<?> anyCollection) {\n2    Iterator<?> iterator = anyCollection.iterator();\n3    while (iterator.hasNext()) {\n4       System.out.print(iterator.next());\n5    }\n6 }\n\n", "heading": "Wildcard Types"}