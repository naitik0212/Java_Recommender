{"content": " \nAside from the java.util.Collection interface, the Java JDK has the java.util.Map interface as well.  It is sometimes also called an Associated Array or a Dictionary.  A map defines key value mappings.  Implementations of the Map interface do not contain collections of objects.  Instead they contain collections of key->value mappings.  It can be thought of as an array where the index doesn't need to be an integer.\n \n\n\n\nCode section 5.17: Use of a map.\n1 import java.util.Map;\n2 import java.util.Hashtable;\n3 ...\n4 Map map = new Hashtable();\n5 ...\n6 map.put(key, value);\n\n Use the Map interface if you need to keep related objects together in a Map where you can:\n Access an element by a key object\nMap one object to other \n\nFigure 5.6: Map Interfaces.\n\n\n\n java.util.Map<K,V>\u00a0\nmaps keys to values. A map cannot contain duplicate keys; each key can map to at most one value. The Map interface provides three collection views, which allow a map's contents to be viewed as a set of keys, collection of values, or set of key-value mappings. The key is usually a non-mutable object. The value object however can be a mutable object.\njava.util.SortedMap<K,V>\u00a0\nsame as the Map interface, plus the keys in the Map are sorted. In the above example, the same operations are made with two different map implementations:\n \n\n\n\n\n\n\nCode listing 5.4: MapImplementations.java\n 1 import java.util.LinkedHashMap;\n 2 import java.util.Map;\n 3 import java.util.TreeMap;\n 4 \n 5 /**\n 6  * Compare the map implementations.\n 7  *\n 8  * @author xxx\n 9  */\n10 public class MapImplementations {\n11 \n12   /**\n13    * Compare the map implementations.\n14    * @param args The execution parameters.\n15    */\n16   public static void main(String[] args) {\n17     processMap(new LinkedHashMap<String, Integer>());\n18 \n19     processMap(new TreeMap<String, Integer>());\n20   }\n21 \n22   /**\n23    * Use a map:\n24    * 1. Fill the map with key-> value.\n25    * 2. Print all the keys.\n26    *\n27    * @param map The used map.\n28    */\n29   public static void processMap(Map<String, Integer> map) {\n30     System.out.println(\"Process the map\");\n31     map.put(\"3\", new Integer(3));\n32     map.put(\"2\", new Integer(2));\n33     map.put(\"1\", new Integer(1));\n34 \n35     for (String key : map.keySet()) {\n36       System.out.println(key);\n37     }\n38   }\n39 }\n\n\n\n\n\n\n\n\nConsole for Code listing 5.4\nProcess the map\n3\n2\n1\nProcess the map\n1\n2\n3\n\n\n We see that only the TreeMap has sorted the keys. Beware of the generics. The Map interface is tricky. The methods get() and remove() are not generic. This means that you must be careful of the type of the key:\n \n\n\n\n\n\n\nCode section 5.18: Tricky generics.\n 1 Map<Integer, String> map = new TreeMap<Integer, String>();\n 2 \n 3 map.put(new Integer(1), \"Watch\");\n 4 map.put(new Integer(2), \"out\");\n 5 map.put(new Integer(3), \"!\");\n 6 \n 7 map.remove(\"2\");\n 8 \n 9 for (String value : map.values()) {\n10   System.out.println(value);\n11 }\n\n\n\n\n\n\n\n\nConsole for Code section 5.18\nWatch\nout\n!\n\n\n The remove() call has done nothing because \"2\" is a String, not an Integer so no key and value has been found and removed.\n Map Classes[edit] The Map interface has the following implementations:\n \n\nFigure 5.7: Map class diagram.\n\n\n\n java.util.TreeMap<E>\nguarantees that the map will be in ascending key order, sorted according to the natural order for the key's class, not-synchronized.\njava.util.Hashtable<E>\u00a0\nSynchronized, null can not be used as key\njava.util.HashMap<E>\u00a0\nis roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls\njava.util.concurrent.ConcurrentHashMap\u00a0\nsame as Hashtable, plus retrieval operations (including get) generally do not block, so may overlap with update operations (including put and remove).\njava.util.WeakHashMap<E>\u00a0\nentry in a WeakHashMap will automatically be removed when its key is no longer in ordinary use. Non-synchronized.\njava.util.LinkedHashMap<E>\u00a0\nThis linked list defines the iteration ordering, which is normally the order in which keys were first inserted into the map (first insertion-order). Note that insertion order is not affected if a key is re-inserted into the map.\njava.util.IdentityHashMap\u00a0\nThis class implements the Map interface with a hash table, using reference-equality in place of object-equality when comparing keys (and values). In other words, in an IdentityHashMap, two keys k1 and k2 are considered equal if and only if (k1==k2). (In normal Map implementations (like HashMap) two keys k1 and k2 are considered equal if and only if (k1==null\u00a0? k2==null\u00a0: k1.equals(k2)).) Not-synchronized.\njava.util.EnumMap\u00a0\nAll of the keys in an enum map must come from a single enum type that is specified, explicitly or implicitly, when the map is created. Enum maps are represented internally as arrays. This representation is extremely compact and efficient. Not-synchronized.", "heading": "intro_Map"}