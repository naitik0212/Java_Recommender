{"content": "\nAny piece of code written in the Java programming language can be run on any operating system, platform or architecture \u2014 in fact, it can be run on any device that supports the Java platform. Before Java, this amount of ubiquity was very hard to achieve. If a software was written for a Unix-based system, it was impossible to run the same application on a Windows system \u2014 in this case, the application was native only to Unix-based systems.\n\nA major milestone in the development of the Java programming language was to develop a special runtime environment that would execute any Java application independent of the computer's operating system, platform or architecture.\n\nThe Java Runtime Environment (JRE) sits on top of the machine's operating system, platform and architecture. If and when a Java application is run, the JRE acts as a liaison between the underlying platform and that application. It interprets the Java application to run in accordance with the underlying platform, such that upon running the application, it looks and behaves like a native application. The part of the JRE that accomplishes this complex liaison agreement is called the Java Virtual Machine (JVM).\n\n\n\nFigure 1: Java applications can be written once and run anywhere. This feature of the Java platformis commonly abbreviated to WORA in formal Java texts.\n\n\n\n\nExecuting native Java code (or byte-code)[edit]\nNative Java applications are preserved in a special format called the byte-code. Byte-code remains the same, no matter what hardware architecture, operating system, or software platform it is running under. On a file-system, Java byte-code resides in files that have the .class (also known as a class file) or the .jar (also known as a Java archive) extension. To run byte-code, the JRE comes with a special tool (appropriately named java).\n\nSuppose your byte-code is called SomeApplication.class. If you want to execute this Java byte-code, you would need to use the following command in Command Prompt (on Windows) or Terminal (on Linux or Mac OS):\n\n\n\n\n\nExecution\n$ java SomeApplication\n\n\nIf you want to execute a Java byte-code with a .jar extension (say, SomeApplication.jar), you would need to use the following command in Command Prompt (on Windows) or Terminal (on Linux or Mac OS):\n\n\n\n\n\nExecution with a jar\n$ java -jar SomeApplication.jar\n\n\n\n\n\n\nNot all Java class files or Java archives are executable. Therefore, the java tool would only be able to execute files that are executable. Non-executable class files and Java archives are simply called class libraries.\n\nDo you have a JRE?[edit]\nMost computers come with a pre-installed copy of the JRE. If your computer doesn't have a JRE, then the above commands would not work. You can always check what version of the JRE is installed on the computer by writing the following command in Command Prompt (on Windows) or Terminal (on Linux or Mac OS):\n\n\n\n\n\nJava version\n$ java -version\n\n\nJava Virtual Machine (JVM)[edit]\nQuite possibly, the most important part of the JRE is the Java Virtual Machine (JVM). The JVM acts like a virtual processor, enabling Java applications to be run on the local system. Its main purpose is to interpret (read translate) the received byte-code and make it appear as native code. The older Java architecture used this process of interpretation to execute Java byte-code. Even though the process of interpretation brought the WORA principle to diverse machines, it had a drawback \u2014 it consumed a lot of time and clocked the system processor intensively to load an application.\n\n\n\nFigure 2: A JVM interpreter translates the byte-code line-by-line to make it appear as if a native application is being executed.\n\n\n\n\nJust-in-Time Compilation[edit]\nSince version 1.2, the JRE features a more robust JVM. Instead of interpreting byte-code, it down-right converts the code straight into equivalent native code for the local system. This process of conversion is called just-in-time compilation or JIT-compilation. This process only occurs when the byte-code is executed for the first time. Unless the byte-code itself is changed, the JVM uses the compiled version of the byte-code on every successive execution. Doing so saves a lot of time and processor effort, allowing applications to execute much faster at the cost of a small delay on first execution.\n\n\n\nFigure 3: A just-in-time compiler only compiles the byte-code to equivalent native code at first execution. Upon every successiveexecution, the JVM merely uses the already compiled native code to optimize performance.\n\n\n\n\nNative optimization[edit]\nThe JVM is an intelligent virtual processor. It has the ability to identify areas within the Java code itself that can be optimized for faster and better performance. Based on every successive run of your Java applications, the JVM would optimize it to run even better.\n\n\n\n\n\nThere are portions of Java code that do not require it to be JIT-compiled at runtime, e.g., the Reflection API; therefore, code that uses such functions are not necessarily fully compiled to native code.\n\nWas JVM the first virtual machine?[edit]\nJava was not the first virtual-machine-based platform, though it is by far the most successful and well-known.  Previous uses for virtual machine technology primarily involved emulators to aid development for not-yet-developed hardware or operating systems, but the JVM was designed to be implemented entirely in software, while making it easy to efficiently port an implementation to hardware of all kinds.\n", "heading": "Java Runtime Environment (JRE)"}