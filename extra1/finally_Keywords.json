{"content": "\nfinally is a keyword which is an optional ending part of the try block.\n\n\n\n\n\nCode section 1: try block.\n1 try {\n2   // ...\n3 } catch (MyException1 e) {\n4   // Handle the Exception1 here\n5 } catch (MyException2 e) {\n6   // Handle the Exception2 here\n7 } finally {\n8   // This will always be executed no matter what happens\n9 }\n\n\nThe code inside the finally block will always be executed. This is also true for cases when there is an exception or even executed return statement in the try block.\n\nThree things can happen in a try block. First, no exception is thrown:\n\n\n\n\n\n\n\n\nCode section 2: No exception is thrown.\n 1 System.out.println(\"Before the try block\");\n 2 try {\n 3   System.out.println(\"Inside the try block\");\n 4 } catch (MyException1 e) {\n 5   System.out.println(\"Handle the Exception1\");\n 6 } catch (MyException2 e) {\n 7   System.out.println(\"Handle the Exception2\");\n 8 } finally {\n 9   System.out.println(\"Execute the finally block\");\n10 }\n11 System.out.println(\"Continue\");\n\n\n\n\n\n\n\n\nConsole for Code section 2\nBefore the try block\nInside the try block\nExecute the finally block\nContinue\n\n\n\nYou can see that we have passed in the try block, then we have executed the finally block and we have continued the execution. Now, a caught exception is thrown:\n\n\n\n\n\n\n\n\nCode section 3: A caught exception is thrown.\n 1 System.out.println(\"Before the try block\");\n 2 try {\n 3   System.out.println(\"Enter inside the try block\");\n 4   throw new MyException1();\n 5   System.out.println(\"Terminate the try block\");\n 6 } catch (MyException1 e) {\n 7   System.out.println(\"Handle the Exception1\");\n 8 } catch (MyException2 e) {\n 9   System.out.println(\"Handle the Exception2\");\n10 } finally {\n11   System.out.println(\"Execute the finally block\");\n12 }\n13 System.out.println(\"Continue\");\n\n\n\n\n\n\n\n\nConsole for Code section 3\nBefore the try block\nEnter inside the try block\nHandle the Exception1\nExecute the finally block\nContinue\n\n\n\nWe have passed in the try block until where the exception occurred, then we have executed the matching catch block, the finally block and we have continued the execution. Now, an uncaught exception is thrown:\n\n\n\n\n\n\n\n\nCode section 4: An uncaught exception is thrown.\n 1 System.out.println(\"Before the try block\");\n 2 try {\n 3   System.out.println(\"Enter inside the try block\");\n 4   throw new Exception();\n 5   System.out.println(\"Terminate the try block\");\n 6 } catch (MyException1 e) {\n 7   System.out.println(\"Handle the Exception1\");\n 8 } catch (MyException2 e) {\n 9   System.out.println(\"Handle the Exception2\");\n10 } finally {\n11   System.out.println(\"Execute the finally block\");\n12 }\n13 System.out.println(\"Continue\");\n\n\n\n\n\n\n\n\nConsole for Code section 4\nBefore the try block\nEnter inside the try block\nExecute the finally block\n\n\n\nWe have passed in the try block until where the exception occurred and we have executed the finally block. NO CODE after the try-catch block has been executed. If there is an exception that happens before the try-catch block, the finally block is not executed.\n\nIf return statement is used inside finally, it overrides the return statement in the try-catch block.  For instance, the construct\n\n\n\n\n\nCode section 5: Return statement.\n1  try {\n2    return 11;\n3  }  finally {\n4    return 12;\n5  }\n\n\nwill return 12, not 11. Professional code almost never contains statements that alter execution order (like return, break, continue) inside the finally block, as such code is more difficult to read and maintain.\n", "heading": "finally"}